<h1 id="spi-port">Serial Peripheral Interface (SPI)</h1>

---
**Note**

The _Master/Slave_ terminology for I2C is considered obsolete. _Master_ is now _Controller_ and _Slave_ is now _Peripheral_. As such MOSI/MISO/SS are now referred as SDI/SDO/CS. This will reflected in the API in the future.

---

The **Serial Peripheral Interface** allows you to send or receive a data stream over a synchronous serial interface made of 3 to 4 lines.

- SDO: Serial Data Out, an output pin to send data to other devices.
- SDI: Serial Data In, an input pin to receive data from other devices.
- SCK: Serial Clock, generated by the controller device to synchronise data transfers.
- CS: Chip select, used by the controller to start communication with a peripheral.

A typical use case of this interface is with SDCard, memory blocks and DACs or ADCs.

This highly configurable interface has elements you can adjust:

- Frame length.
- Clocks polarity and phase.

## Assumptions

### Defined behaviors

- `spi_get_module()` returns a unique identifier to the peripheral associated to this SPI channel.
- `spi_get_capabilities()` fills the given `spi_capabilities_t` instance.
- `spi_get_capabilities()` should consider the `ssel` pin when evaluating the `support_slave_mode` capability.
- If the given `ssel` pin cannot be managed by hardware in Peripheral mode, the `support_slave_mode` attribute should be false.
- At least a symbol width of 8 bits must be supported.
- The supported frequency range must include the range 0.2 MHz to 2 MHz.
- The shortest part of the duty cycle must not be shorter than 50% of the expected period.
- `spi_init()` initializes the pins leaving the configuration registers unchanged.
- `spi_init()`:
   - If `ssel` is `NC`, the HAL implementation ignores this pin.
   - If `ssel` is not `NC`, then the HAL implementation owns the pin and its management.
- When managed by the HAL implementation, `ssel` is always considered active low.
- When the hardware supports the half-duplex (3-wire) mode, if `miso` (exclusive) or `mosi` is missing in any function that expects pins, the bus is assumed to be half-duplex.
- `spi_free()` resets the pins to their default state.
- `spi_free()` disables the peripheral clock.
- `spi_format()` sets:
   - The number of bits per symbol.
   - The mode:   
      |  SPI Mode  |  Clock edge  |  Clock polarity  |   Clock phase  |
      |---         |---           |---               |---             |
      |  0         |  1           | 0                | 0              |
      |  1         |  0           | 0                | 1              |
      |  2         |  1           | 1                | 0              |
      |  3         |  0           | 1                | 1              |
   - The bit ordering (lsb/msb first).
- `spi_format()` updates the configuration of the peripheral except the baud rate generator.
- `spi_frequency()` sets the frequency to use during the transfer.
- `spi_frequency()` returns the actual frequency that is used.
- `spi_frequency()` updates the baud rate generator leaving other configurations unchanged.
- `spi_init()`, `spi_frequency()` and `spi_format()` must be called at least once each before initiating any transfer.
- `spi_master_transfer()`:
   - Writes `tx_length` symbols to the bus.
   - Reads `rx_length` symbols from the bus.
   - If `rx` is NULL, then inputs are discarded.
   - If `tx` is NULL, then wait for data to be received.
   - Expects symbols types to be the closest stdint type bigger or equal to its size following the platform's endianness.  
   For example:
      - 7bits => uint8_t.
      - 15bits => uint16_t.
      - 16bits => uint16_t.
      - 17bits => uint32_t.
   - In full-duplex mode:
      - If `rx_length` is greater than `tx_length` then it sends `(rx_length - tx_length)` additional `fill_symbol` to the bus.
  - In half-duplex mode:
      - As controller, `spi_master_transfer()` sends `tx_length` symbols and then reads `rx_length` symbols.
      - As peripheral, `spi_master_transfer()` receives `rx_length` symbols and then sends `tx_length` symbols.
- The callback given to `spi_master_transfer()` is invoked when the transfer completes (with a success or an error)
- The context is passed to the callback on transfer completion.
- Unless the transfer is aborted, the callback is invoked on completion. The completion may be when all symbols have been transmitted
  or when, in Peripheral mode, the master deasserts the chip select.
- `spi_abort_asynch()` aborts an ongoing asynchronous transfer.

### Undefined behaviors

- Calling `spi_init()` multiple times on the same `spi_t` object without `spi_free()`'ing it first.
- Calling any method other than `spi_init()` on an uninitialized or freed `spi_t` object.
- Passing both `miso` and `mosi` as `NC` to `spi_get_module` or `spi_init`.
- Passing `miso` or `mosi` as `NC` to an MCU that does not support half-duplex mode.
- Passing `mclk` as `NC`  to `spi_get_module` or `spi_init`.
- Passing an invalid pointer as `cap` to `spi_get_capabilities`.
- Passing pins that cannot be on the same peripheral.
- Passing an invalid SPI object pointer to any method.
- Giving an `ssel` pin to `spi_init()` when using in Controller mode.
- SS must be managed by hardware in Peripheral mode and must **NOT** be managed by hardware in Controller mode.
- Setting a frequency outside of the range given by `spi_get_capabilities()`.
- Setting a frequency in Peripheral mode.
- Setting `bits` in `spi_format` to a value out of the range given by `spi_get_capabilities()`.
while they would be required by the transfer (`rx_length != tx_length` or `tx==NULL`).
- Passing an invalid address as `handler` to `spi_master_transfer`.
- Calling `spi_abort_asynch()` while no asynchronous transfer is being processed (no transfer or a synchronous transfer).
- In half-duplex mode, any mechanism (if any is present) to detect or prevent collision is implementation defined.

### Other requirements

An MCU must also define these elements:

- `DEVICE_SPI_COUNT`.
- The number of SPI peripherals available on the device. A good place for that macro is `PeripheralNames.h` next to the `SPIName` enumeration.

## Dependencies

Hardware SPI capabilities.

## Implementing the SPI API

You can find the API and specification for the SPI API in the following class reference:

[![View code](../../images/view_library_button.png)](https://mcu-driver-hal.github.io/MCU-Driver-HAL/doxygen/html/group__hal___general_s_p_i.html)

To enable SPI support add `DEVICE_SPI=1` in the CMake variable `MBED_TARGET_DEFINITIONS`.
You can also add the `DEVICE_SPI_ASYNCH=1` in the CMake variable `MBED_TARGET_DEFINITIONS` to enable the asynchronous API.

## Testing

MCU-Driver-HAL provides a set of conformance tests for SPI. You can use these tests to validate the correctness of your implementation.

Steps to run the SPI HAL tests will be provided in the future.
